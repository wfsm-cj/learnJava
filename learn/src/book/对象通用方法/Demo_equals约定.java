package book.对象通用方法;

/**
 * @author chenjie
 * @date 2021/5/16-10:48
 */
public class Demo_equals约定 {
    /*
    * 等价关系 ：
    *       不严格的说，他是一个操作符，将一组元素划分到其元素与另一个元素等价的分组中。
    * 这些分组被称作等价类（equivalence class）
    *    对于有用的equals方法中，每个等价类中的所有元素都必须是可交换的
    * */

    /*
    * equals 约定
    *       自反性 reflexivity
    *           对象必须等于其自身。如果违背了这一条，把该类实例添加到集合中，该集合的
    * contains 方法将果断的告诉你，该集合不包含你刚刚添加的实例
    *   对称性 symmetry  -- CaseInsensitiveString例子
    *       任何两个对象对于“它们是否相等”的问题，都必须保持一致。
    *           必须要判断 传入对象是否为该类对象， 否则对称的时候，就会去调用其他类的equals方法，可能会不相等
    *   传递性（transitivity）
    *       如果一个对象等于第二个对象，而第二个对象又等于第三个对象，则第一个对象一定等于第三个对象
    *       我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留equals约定。比如子类添加了一个
    * 新的值组件，重写了equals。显然 父类的 equals 和子类的 equals是不同的，所以你只有放弃面向对象抽象
    * 所带来的优势，也就是多态的优势，不然 不能满足传递性，比如 子类1 == 父类1， 子类2 == 父类2，
    * 子类1 肯定不等于 子类2 ，因为它们 新的值组件的值是不同的
    *       此外，这种方法还可能导致无限递归问题，假设 Point 有两个子类，如 ColorPoint 和 SmellPoint
    * 它们各自都带有这种 equals 方法， 那么对  myColorPoint.equals(mySmellPoint) 的调用将会抛出
    * StackOverflowError
    *   用 getclass 测试代替 instanceof 测试，可以扩展可实例化的类，来实现只能对象具有相同实现类的时候
    * 但不能测试 父类 ，只能测试本类对象  o.getClass() == this.getClass()
    *
    *  --> 似乎得出了一个结论， 继承的都不能满足传递性？？
    *
    * */

    /*
    * 里氏替换原则 (Liskov substitution priciple)
    *    一个类型的任何重要属性也将适用于它的子类型，因此为该类型编写的任何方法，在它的
    * 子类型上也应该同样运行的很好
    *       如果 在equals 中 用 getClass，它的子类型传进去的时候就不再适用了
    * 用 instanceof 就能适用
    *
    * */

    /*
    * 虽然没有一种令人满意的办法，可以既扩展不可实例化的类，又增加值组件
    * 但是 可以 “复合优先于继承”
    *
    * */
}
