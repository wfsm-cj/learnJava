package 设计模式2.creationalPatterns.原型模式;

/**
 * @author chenjie
 * @date 2021/5/20-8:50
 */
public class Demo {
    /*原型模式
    * 用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象
    * 优点：
    *      提高性能
    * 缺点
    *   已有的类没有写相应的clone方法，较为麻烦
    * 使用场景：
    *       类初始化需要很多资源，性能和安全有要求的场景
    * */

    /*
    * 三个角色;
    *       1，客户角色(Client) : 客户类提出创建对象的请求
    *       2，抽象原型(Prototype)角色： 此角色定义了的具体原型类所需的实现的方法。   一个被要被复制的抽象类
    *       3，具体原型(Concrete Prototype)  concrete 实在的 有形的 混凝土
    *               实现抽象原型角色的克隆接口。      抽象类原型 的实现类
    *
    * */
    /*
    * 原型模式的核心就是拷贝对象
    *       浅拷贝
    *           我们只拷贝对象中的基本数据类型（8种），对于数组，容器，引用对象等都不会拷贝
    *       深拷贝
    *           不仅能拷贝基本数据类型，还能拷贝那些数组，容器，引用对象等
    *
    * */

    /*
    * 分析原型模式：
    *       1，克隆对象不会调用构造方法。。这是因为执行clone方法的时候是直接从内存中
    * 去获取数据的，在第一次创建对象的时候就会把数据在内存保留一份，克隆的时候直接调用就好了
    *       2，访问权限对原型模式无效
    *           原理也很简单，我们是从内存中直接赋值的，所以克隆起来也会直接无视
    * */
}
